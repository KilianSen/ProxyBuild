name: 'ProxyBuild Action'
description: 'Build command proxy executables with embedded configuration'
author: 'Your Name'

branding:
  icon: 'box'
  color: 'blue'

inputs:
  config-file:
    description: 'Path to the proxy configuration file (JSON)'
    required: true
  output-name:
    description: 'Name of the output executable (optional, defaults to <base_command>-proxy)'
    required: false
    default: ''
  go-version:
    description: 'Go version to use'
    required: false
    default: '1.24'
  upload-artifact:
    description: 'Whether to upload the built executable as an artifact'
    required: false
    default: 'true'
  target-os:
    description: 'Target operating system for cross-compilation (e.g., linux, windows, darwin)'
    required: false
    default: ''
  target-arch:
    description: 'Target architecture for cross-compilation (e.g., amd64, arm64)'
    required: false
    default: ''

outputs:
  executable-path:
    description: 'Path to the built executable'
    value: ${{ steps.build.outputs.executable-path }}
  executable-name:
    description: 'Name of the built executable'
    value: ${{ steps.build.outputs.executable-name }}

runs:
  using: 'composite'
  steps:
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ inputs.go-version }}

    - name: Checkout ProxyBuild
      uses: actions/checkout@v4
      with:
        repository: YOUR_USERNAME/ProxyBuild
        path: .proxybuild-temp
        # Build command with optional cross-compilation flags
        BUILD_CMD="./ProxyBuild -build ${{ github.workspace }}/${{ inputs.config-file }}"
        
        if [ -n "${{ inputs.target-os }}" ]; then
          BUILD_CMD="$BUILD_CMD -os ${{ inputs.target-os }}"
        fi
      id: build
        if [ -n "${{ inputs.target-arch }}" ]; then
          BUILD_CMD="$BUILD_CMD -arch ${{ inputs.target-arch }}"
        fi

      run: |
          BUILD_CMD="$BUILD_CMD -output ${{ inputs.output-name }}"
        cd .proxybuild-temp
        go build -o ProxyBuild main.go
        
        # Build the proxy executable
        ./ProxyBuild -build "${{ github.workspace }}/${{ inputs.config-file }}"
          # Add .exe for Windows builds
          if [ "${{ inputs.target-os }}" = "windows" ]; then
            OUTPUT_NAME="${OUTPUT_NAME}.exe"
          fi
        
        
        echo "Building with: $BUILD_CMD"
        eval $BUILD_CMD
        # Determine output name
        if [ -n "${{ inputs.output-name }}" ]; then
          OUTPUT_NAME="${{ inputs.output-name }}"
        else
          # Extract base_command from config to determine default name
          BASE_CMD=$(jq -r '.base_command' "${{ github.workspace }}/${{ inputs.config-file }}")
          OUTPUT_NAME="${BASE_CMD}-proxy"
        fi
        
        # Move executable to workspace root
        mv "${OUTPUT_NAME}" "${{ github.workspace }}/${OUTPUT_NAME}"
        
        echo "executable-path=${{ github.workspace }}/${OUTPUT_NAME}" >> $GITHUB_OUTPUT
        echo "executable-name=${OUTPUT_NAME}" >> $GITHUB_OUTPUT
        
        echo "âœ… Built executable: ${OUTPUT_NAME}"

    - name: Make executable
      shell: bash
      run: |
        chmod +x "${{ steps.build.outputs.executable-path }}"

    - name: Upload artifact
      if: inputs.upload-artifact == 'true'
      with:
        name: ${{ steps.build.outputs.executable-name }}
        path: ${{ steps.build.outputs.executable-path }}

    - name: Cleanup
      shell: bash
      run: rm -rf .proxybuild-temp
